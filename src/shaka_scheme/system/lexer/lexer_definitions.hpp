//
// Created by aytas on 10/31/2017.
//

#ifndef SHAKA_SCHEME_LEXER_DEFINITIONS_HPP
#define SHAKA_SCHEME_LEXER_DEFINITIONS_HPP

#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <functional>

namespace shaka {
namespace lexer {

/**
 * @brief Stores the filename and string position tracking info.
 */
struct LexInfo {
  std::string filename;
  int pos;
  int row;
  int col;
};

bool operator==(LexInfo left, LexInfo right);

bool operator!=(LexInfo left, LexInfo right);

/**
 * @brief Prints out the LexInfo in a readable format.
 * @param left The output stream reference.
 * @param right The LexInfo object to print out.
 * @return The updated version of the output stream.
 */
std::ostream& operator<<(std::ostream& left, const LexInfo& right);

/**
 * @brief A simple class to store the result of a parse.
 */
struct LexResult {
  LexResult(std::string type,
              std::string str,
              LexInfo info = {"<generic-input>", 0, 0, 0},
              std::string token_type = "");

  /**
   * @brief The object for tracking file position.
   */
  LexInfo info;

  /**
   * @brief The type of the current result. Usually error, token, or incomplete.
   */
  std::string type;

  /**
   * @brief The type of the token parsed.
   */
  std::string token_type;

  /**
   * @brief The contents of the token parsed or consumed by the token or
   * erronous parse.
   */
  std::string str;

  bool is_error() const;
  bool is_token() const;
  bool is_incomplete() const;
};

bool operator==(const LexResult& left, const LexResult& right);

bool operator!=(const LexResult& left, const LexResult& right);

/**
 * @brief A pseudo-constructor for an LexResult error.
 * @param str The part of input that caused the error.
 * @param info The lexical info of the starting position of the input.
 * @param token_type Description of the error.
 * @return The LexResult object with the type "error".
 */
LexResult Error(std::string str, LexInfo info, std::string token_type);

/**
 * @brief A pseudo-constructor for a LexResult token.
 * @param str The string contents of the token.
 * @param info The lexical info of the starting position of the token in the
 * input.
 * @param token_type The "tag" for type for the token.
 * @return The constructed LexResult object with the type "token".
 */
LexResult Token(std::string str, LexInfo info, std::string token_type);

/**
 * @brief A pseudo-constructor for a LexResult incomplete marker.
 * @param str Not used.
 * @param info The lexical info of where the parse left off.
 * @return The "incomplete"-marked LexResult object.
 */
LexResult Incomplete(std::string str, LexInfo info);

/**
 * @brief Prints out a readable form for the LexResult.
 * @param left The output stream to write to.
 * @param right The LexResult object to print.
 * @return The updated version of the output stream.
 */
std::ostream& operator<<(std::ostream& left, LexResult right);

/**
 * @brief An exception type for any Lexer exceptions.
 */
struct LexerException : public std::exception {
  std::string str;

  /**
   * @brief Takes in the error message string and the lexical info.
   * @param str The error message.
   * @param info The lexical info.
   */
  LexerException(std::string str, LexInfo info);

  /**
   * @brief The error string automatically generated by the exception.
   * @return The generated error string.
   */
  const char * what() const noexcept;
};

/**
 * @brief A utility class for wrapping a string with a tracking index and
 * lexical info, with methods for peeking, getting, ungeting, and appending
 * input.
 */
struct LexerInput {
  std::string input;
  int curr;
  LexInfo info;

  /**
   * @brief Takes in the initial input string and the name of the "module" or
   * "filename" of origin.
   * @param input The input string to take input from.
   * @param name The name of the "marker" for the LexInfo.
   */
  LexerInput(std::string input, std::string name = "<generic-input>");

  int index();

  char peek();

  LexInfo get_info();

  void set_info(LexInfo info);

  char get();

  LexInfo info_then_get();

  void unget(std::vector<LexResult> tokens);

  void append_input(std::string more_input);
};

using LexerRule = std::function<LexResult(LexerInput&)>;

LexerRule sequence(LexerRule left,
                   LexerRule right,
                   std::string type = "");

LexerRule make_terminal(std::string str, std::string type = "");

LexerRule make_class(std::function<bool(char)> pred, std::string type);

LexerRule operator+(LexerRule left, LexerRule right);

LexerRule alternative(LexerRule left,
                      LexerRule right,
                      std::string token_type = "");

LexerRule operator|(LexerRule left, LexerRule right);

LexerRule kleene(LexerRule rule);

LexerRule operator*(LexerRule rule);

LexerRule with_label(LexerRule rule, std::string label);

LexerRule operator/(LexerRule rule, std::string right);

LexResult empty_string(LexerInput& lex);

LexerRule repeat(LexerRule rule, std::size_t times);

LexerRule operator*(LexerRule rule, std::size_t right);

LexerRule operator*(std::size_t left, LexerRule rule);

LexerRule suffix_action(LexerRule rule,
                         std::function<LexResult(LexResult)> func);

LexerRule operator&(LexerRule left, std::function<LexResult(LexResult)> func);

LexerRule prefix_action(LexerRule rule,
                        std::function<void(LexerInput&)> func);

LexerRule operator&(std::function<void(LexerInput&)> func, LexerRule rule);

LexerRule reject_if(LexerRule rule);

LexerRule operator!(LexerRule rule);

} // namespace lexer
} // namespace shaka

#endif //SHAKA_SCHEME_LEXER_DEFINITIONS_HPP
